use crate::types::{Secret, SecretStore};
use anyhow::{anyhow, Result};
use chrono::{DateTime, Duration, Utc};
use rand::distributions::Alphanumeric;
use rand::{thread_rng, Rng};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use uuid::Uuid;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RotationPolicy {
    pub secret_id: Uuid,
    pub interval_days: u32,
    pub auto_rotate: bool,
    pub last_rotated: Option<DateTime<Utc>>,
    pub next_rotation: Option<DateTime<Utc>>,
    pub rotation_type: RotationType,
    pub custom_generator: Option<String>, // For future extensibility
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum RotationType {
    Manual,           // User provides new value
    AutoGenerated,    // System generates new password
    ExternalScript,   // Run external script to generate
}

pub struct RotationManager {
    policies: HashMap<Uuid, RotationPolicy>,
}

impl RotationManager {
    pub fn new() -> Self {
        Self {
            policies: HashMap::new(),
        }
    }

    /// Add or update a rotation policy for a secret
    pub fn set_policy(
        &mut self,
        secret_id: Uuid,
        interval_days: u32,
        auto_rotate: bool,
        rotation_type: RotationType,
    ) -> Result<()> {
        let next_rotation = if interval_days > 0 {
            Some(Utc::now() + Duration::days(interval_days as i64))
        } else {
            None
        };

        let policy = RotationPolicy {
            secret_id,
            interval_days,
            auto_rotate,
            last_rotated: None,
            next_rotation,
            rotation_type,
            custom_generator: None,
        };

        self.policies.insert(secret_id, policy);
        Ok(())
    }

    /// Get rotation policy for a secret
    pub fn get_policy(&self, secret_id: &Uuid) -> Option<&RotationPolicy> {
        self.policies.get(secret_id)
    }

    /// Remove rotation policy for a secret
    pub fn remove_policy(&mut self, secret_id: &Uuid) -> Option<RotationPolicy> {
        self.policies.remove(secret_id)
    }

    /// Get all secrets due for rotation
    pub fn get_secrets_due_for_rotation(&self) -> Vec<Uuid> {
        let now = Utc::now();
        self.policies
            .values()
            .filter(|policy| {
                policy.next_rotation
                    .map(|next| next <= now)
                    .unwrap_or(false)
            })
            .map(|policy| policy.secret_id)
            .collect()
    }

    /// Get secrets that will be due for rotation within the specified days
    pub fn get_secrets_due_within_days(&self, days: u32) -> Vec<Uuid> {
        let cutoff = Utc::now() + Duration::days(days as i64);
        self.policies
            .values()
            .filter(|policy| {
                policy.next_rotation
                    .map(|next| next <= cutoff)
                    .unwrap_or(false)
            })
            .map(|policy| policy.secret_id)
            .collect()
    }

    /// Rotate a specific secret
    pub fn rotate_secret(
        &mut self,
        store: &mut SecretStore,
        secret_id: &Uuid,
        new_value: Option<String>,
    ) -> Result<String> {
        let secret = store.secrets.get_mut(secret_id)
            .ok_or_else(|| anyhow!("Secret not found"))?;

        let old_value = secret.value.clone();

        // Determine new value
        let new_secret_value = if let Some(value) = new_value {
            value
        } else if let Some(policy) = self.policies.get(secret_id) {
            match policy.rotation_type {
                RotationType::AutoGenerated => {
                    self.generate_new_password(secret)?
                }
                RotationType::Manual => {
                    return Err(anyhow!("Manual rotation requires providing a new value"));
                }
                RotationType::ExternalScript => {
                    return Err(anyhow!("External script rotation not yet implemented"));
                }
            }
        } else {
            return Err(anyhow!("No rotation policy found and no new value provided"));
        };

        // Update the secret
        secret.update_value(new_secret_value.clone());

        // Update rotation policy
        if let Some(policy) = self.policies.get_mut(secret_id) {
            policy.last_rotated = Some(Utc::now());
            policy.next_rotation = if policy.interval_days > 0 {
                Some(Utc::now() + Duration::days(policy.interval_days as i64))
            } else {
                None
            };
        }

        Ok(new_secret_value)
    }

    /// Auto-rotate all secrets that are due and have auto-rotation enabled
    pub fn auto_rotate_due_secrets(&mut self, store: &mut SecretStore) -> Result<Vec<RotationResult>> {
        let mut results = Vec::new();
        let due_secrets = self.get_secrets_due_for_rotation();

        for secret_id in due_secrets {
            if let Some(policy) = self.policies.get(&secret_id) {
                if policy.auto_rotate {
                    match self.rotate_secret(store, &secret_id, None) {
                        Ok(new_value) => {
                            results.push(RotationResult {
                                secret_id,
                                secret_name: store.secrets.get(&secret_id).map(|s| s.name.clone()),
                                success: true,
                                error: None,
                                new_value_length: Some(new_value.len()),
                            });
                        }
                        Err(e) => {
                            results.push(RotationResult {
                                secret_id,
                                secret_name: store.secrets.get(&secret_id).map(|s| s.name.clone()),
                                success: false,
                                error: Some(e.to_string()),
                                new_value_length: None,
                            });
                        }
                    }
                }
            }
        }

        Ok(results)
    }

    /// Get rotation status for all secrets with policies
    pub fn get_rotation_status(&self, store: &SecretStore) -> Vec<RotationStatus> {
        self.policies
            .values()
            .filter_map(|policy| {
                store.secrets.get(&policy.secret_id).map(|secret| {
                    let days_until_rotation = policy.next_rotation
                        .map(|next| (next - Utc::now()).num_days())
                        .unwrap_or(0);

                    let status = if policy.next_rotation.is_none() {
                        "No schedule"
                    } else if days_until_rotation < 0 {
                        "Overdue"
                    } else if days_until_rotation == 0 {
                        "Due today"
                    } else if days_until_rotation <= 7 {
                        "Due soon"
                    } else {
                        "Scheduled"
                    };

                    RotationStatus {
                        secret_id: policy.secret_id,
                        secret_name: secret.name.clone(),
                        policy: policy.clone(),
                        days_until_rotation,
                        status: status.to_string(),
                        last_rotated_days_ago: policy.last_rotated
                            .map(|last| (Utc::now() - last).num_days())
                            .unwrap_or(-1),
                    }
                })
            })
            .collect()
    }

    /// Generate a new password for a secret based on heuristics
    fn generate_new_password(&self, secret: &Secret) -> Result<String> {
        // Analyze the current password to determine generation parameters
        let current_length = secret.value.len();
        let has_symbols = secret.value.chars().any(|c| "!@#$%^&*()_+-=[]{}|;:,.<>?".contains(c));
        let has_numbers = secret.value.chars().any(|c| c.is_ascii_digit());
        let has_uppercase = secret.value.chars().any(|c| c.is_ascii_uppercase());
        let has_lowercase = secret.value.chars().any(|c| c.is_ascii_lowercase());

        // Generate a new password with similar characteristics but stronger
        let length = (current_length.max(16)).min(64); // At least 16 chars, max 64
        
        let charset = if has_symbols && has_numbers && has_uppercase && has_lowercase {
            "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_+-=[]{}|;:,.<>?"
        } else if has_numbers && has_uppercase && has_lowercase {
            "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
        } else {
            "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*"
        };

        let password: String = (0..length)
            .map(|_| {
                let idx = thread_rng().gen_range(0..charset.len());
                charset.chars().nth(idx).unwrap()
            })
            .collect();

        Ok(password)
    }

    /// Generate a simple alphanumeric password
    pub fn generate_simple_password(length: usize) -> String {
        thread_rng()
            .sample_iter(&Alphanumeric)
            .take(length)
            .map(char::from)
            .collect()
    }

    /// Generate a complex password with symbols
    pub fn generate_complex_password(length: usize) -> String {
        let charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_+-=[]{}|;:,.<>?";
        (0..length)
            .map(|_| {
                let idx = thread_rng().gen_range(0..charset.len());
                charset.chars().nth(idx).unwrap()
            })
            .collect()
    }

    /// Load policies from JSON
    pub fn load_policies(&mut self, json_data: &str) -> Result<()> {
        let policies: HashMap<String, RotationPolicy> = serde_json::from_str(json_data)?;
        
        for (key, policy) in policies {
            if let Ok(uuid) = Uuid::parse_str(&key) {
                self.policies.insert(uuid, policy);
            }
        }
        
        Ok(())
    }

    /// Save policies to JSON
    pub fn save_policies(&self) -> Result<String> {
        let string_keyed: HashMap<String, &RotationPolicy> = self.policies
            .iter()
            .map(|(k, v)| (k.to_string(), v))
            .collect();
        
        serde_json::to_string_pretty(&string_keyed)
            .map_err(|e| anyhow!("Failed to serialize policies: {}", e))
    }
}

impl Default for RotationManager {
    fn default() -> Self {
        Self::new()
    }
}

#[derive(Debug, Clone)]
pub struct RotationResult {
    pub secret_id: Uuid,
    pub secret_name: Option<String>,
    pub success: bool,
    pub error: Option<String>,
    pub new_value_length: Option<usize>,
}

#[derive(Debug, Clone)]
pub struct RotationStatus {
    pub secret_id: Uuid,
    pub secret_name: String,
    pub policy: RotationPolicy,
    pub days_until_rotation: i64,
    pub status: String,
    pub last_rotated_days_ago: i64,
}

impl std::fmt::Display for RotationStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "{}: {} ({})",
            self.secret_name,
            self.status,
            if self.days_until_rotation >= 0 {
                format!("{} days until rotation", self.days_until_rotation)
            } else {
                format!("{} days overdue", -self.days_until_rotation)
            }
        )
    }
}